1 F From what was presented in Lecture 22, bushy trees are logN, but spindly trees have linear performance. So super worst-case scenario, you have a spindly tree, and need to put something all the way at the bottom. Not log. 
2 F To be in BigTheta, you have to be in BigO and BigOmega. BigO not satisfied here. 
3 F Good-case scenario: the tree is bushy - it'll take log time. So it's not in BigOmega - can't be in BigTheta.
4 T Worst-case scenario, ya got a super splindly tree. You'll have to traverse the whole thing, this super long line, with no chopping off parts - linear. 
5 T Yeah sure why not. If you're in O(N), O(N^2) is even more encompassing. You'll fit right in. 
6 F Because B.put is 2lnN on average per insert, and then B.containsKey would take 2lnN comparisons on average as well. So each call would take 4lnN, and multiplied by N calls, the total number of comparisons would be 4NlnN.
7 T Best case scenario, even if key C is at the root (which would take constant time), finding key K != C will require traversing through, and best case is traveling through a bushy tree, which would be logN. Constant + logN --> logN.
8 O(N^2) Looking for the node whose size = z, kinda sorta yeah maybe? Japheth says kinda somewhat. Whatever. So worst case scenario, you have a SUPER LEFT-LEANING BST. And you want to find the last node. Ya gotta go all the way down = N. But #Nodes method takes linear time. So N (or like, possibly 3N), and then you do the recurse. So you recurse N times, and each time, you take N time in that if (possibly N + N + N = 3N). Family of N^2. 